# ProjectBS S63 WebGL - Day 3

## Primitive

### 일반적인 프로그래밍에서의 Primitive 

> **어떤 관점(또는 컨텍스트)에서 더 쪼갤 수 없는 자료형을 의미하며, 기본형 또는 원시형이라고도 한다.**

더 쪼갤 수 없다는 것 역시 상대적인 개념으로,
JVM 상에서의 int는 JVM 관점에서는 더 쪼갤 수 없지만, JVM 아래의 OS가 볼 때는 더 쪼갤 수 있으며, 
OS 관점에서의 어떤 자료형이 더 쪼갤 수 없다 하더라도, OS 아래의 H/W 관점에서는 bit 수준으로 더 쪼갤 수 있다.

### WebGL에서의 Primitive(WebGL Rendering Primitive)

> **그릴 수 있는 가장 기본적이고 원시적인 단위의 기하구조**

일상에서 기본 기하구조로 알고 있는 점, 선, 면, 입체와 다르지 않지만, WebGL에서의 입체는 Primitive로 보지 않고 면의 조합으로 보며, 하나의 면을 이루려면 3개의 버텍스, 즉 삼각형이 필요하다.

따라서 **WebGL에서의 Primitive란 크게 보면 점, 선, 삼각형**인데, **선과 삼각형은 그리는 방식에 따라 세분화된 Primitive가 있으며, 아래 그림과 같이 총 7가지의 Primitive가 존재**한다.

>![](https://camo.githubusercontent.com/157ef95b89d133244429dbfa2357b7579c1767f9/687474703a2f2f7074676d656469612e70656172736f6e636d672e636f6d2f696d616765732f63686170335f393738303332313930323932342f656c656d656e744c696e6b732f303366696731335f616c742e6a7067)
> 출처 : [http://www.informit.com/articles/article.aspx?p=2111395&seqNum=2 ](http://www.informit.com/articles/article.aspx?p=2111395&seqNum=2 )

#### 점

책에서는 포인트 스프라이트라고 표현되어있는데, **WebGL에서의 점은 수학적인 점과 달리 크기가 있다.** 점을 그리려면 셰이더의 내장 변수인 `gl_PointSize`를 이용해서 크기를 지정해줘야 한다.

크기가 있으므로 **WebGL의 점은 이미지를 입히는 텍스쳐링도 할 수 있다!!**

WebGL의 점은 삼각형에 비해 훨씬 적은 연산이 필요하므로 **대량의 입자를 표시하는 파티클(Particle) 효과에 사용**된다.

파티클 효과란 대략 이런듯.. 

[http://nullprogram.com/webgl-particles/](http://nullprogram.com/webgl-particles/)

[http://www.ibiblio.org/e-notes/webgl/models/fire.html](http://www.ibiblio.org/e-notes/webgl/models/fire.html)


## Winding Order

삼각형 하나를 그릴 때는 세 개의 버텍스가 필요하며, 삼각형을 그리는 순서(또는 방향)가 존재한다.
삼각형을 그리는 순서(또는 방향)는 두 가지로 구분된다.

- CCW(CounterClockWise) : 반시계 방향
- CW(ClockWise) : 시계 방향

![](http://learnopengl.com/img/advanced/faceculling_windingorder.png)

책에서 `두르기 순서`라고 표현하고 있는 **Winding Order란 삼각형을 그리는 순서로서 결국 CCW(반시계 방향)나 CW(시계 방향) 둘 중의 하나**이다. **WebGL의 기본 Winding Order는 CCW다.**

### Winding Order가 중요한 이유 

>**삼각형이 앞면인지 뒤면인지를 Winding Order을 통해 판별**하고, 
>**뒤면인 경우 해당 삼각형은 래스터라이징 단계 중에 제거되어 연산 부하를 줄일 수 있기 때문**이다.


## 그리기 메서드

WebGL에서의 그리기란 그리기 버퍼(Frame Buffer)를 갱신하는 것을 의미하며, 그리기 메서드는 3가지가 있다.

### gl.clear()

gl.clearColor()로 지정한 색깔로 모든 픽셀을 채운다.

### gl.drawArrays(mode, offset, count)


>mode : 그리기 모드(또는 Primitive : gl.POINTS, gl.LINES, ...)
>offset : 버텍스 버퍼 상에서 그리기에 사용할 버텍스의 시작 인덱스
>count : 버텍스의 개수


인덱스 버퍼를 사용하지 않고 오로지 버텍스 버퍼만을 사용해서 버텍스 버퍼에 있는 순서대로 그린다.

책 138페이지 그림 참조

- 장점
	- 인덱스 버퍼를 사용하지 않고 버텍스 버퍼에서 바로 버텍스 정보를 뽑으므로 데이터 용량을 적게 차지한다.	
- 단점
	- 버텍스가 여러 삼각형에서 공유되는 경우 실제 필요한 버텍스보다 더 많은 버텍스를 사용하게 된다.
	- 버텍스가 여러 삼각형에서 공유되어도 모두 다른 버텍스로 인식하여 캐쉬에 의한 성능 향상 효과를 누릴 수 없다.

결론적으로 연접하지 않는, 즉 버텍스가 공유되지 않는 삼각형이 많을 때 유리하다.

### gl.drawElements(mode, count, type, offset)

>mode : 그리기 모드(또는 Primitive : gl.POINTS, gl.LINES, ...)
>count : 인덱스의 개수
>type : 인덱스의 데이터 타입(기본은 gl.UNSINGED_BYTE)
>offset : 인덱스 버퍼 상에서 그리기에 사용할 인덱스의 시작 인덱스

인덱스 버퍼와 버텍스 버퍼를 함께 사용해서 그린다.

책 139페이지 그림 참조

- 장점
	- 버텍스가 여러 삼각형에서 공유되는 경우 하나의 버텍스를 인덱스 번호만 다르게 해서 재사용 할 수 있다.
	- 버텍스를 재사용 할 수 있으므로 데이터 용량을 절약할 수 있고, 캐쉬에 의한 성능 향상 효과를 누릴 수 있다.
- 단점
	- 인덱스 버퍼를 통해서 버텍스 정보를 뽑으므로 인덱스가 효율적으로 구성되지 않을 경우 성능이 낮다.
	
결론적으로 연접하는 삼각형이 많을 떄 유리하며, 실무에서는 삼각형이 연접하여 메쉬를 구성하는 경우가 대부분이므로 가장 많이 사용된다.

## 겹치기 삼각형

실무적으로는 사람이 하지 않고 3d Max같은 도구가 해주므로 걍 션하게 Skip!!   

## ArrayBuffer

> **WebGL에서의 ArrayBuffer란 일반적인 프로그래밍에서의 ByteArray를 말한다.**
> ByteArray란 각 원소가 1byte로 되어있고, 각 원소가 메모리 상에 연속적으로 존재하는 배열을 말한다.

### ArrayBuffer를 왜 쓰는가

**JavaScript의 `Array`는 이름과는 달리 메모리 상에 연속적으로 존재하는 자료구조가 아니고, 일반적인 프로그래밍에서 말하는 LinkedList에 해당한다.**

**GPU는 LinkedList가 아니라 Array만** 받을 수 있다. 따라서 **WebGL API를 통해 GPU에 배열을 넘기려면 JavaScript에도 일반적인 프로그래밍에서 말하는 진정한 Array에 해당하는 자료구조가 필요**하다. **JavaScript에서 진정한 Array에 해당하는 자료구조가 바로 ArrayBuffer다.**

GPU와의 관련성을 강조하기 위해 Buffer라는 이름을 사용하는 듯

## TypedArray

> **TypeArray는 ArrayBuffer의 View이다.**

ArrayBuffer는 자료구조를 생성하지만, ArrayBuffer를 통해서는 그 자료구조 내의 데이터에 접근할 수 없다.
ArrayBuffer는 MVC 패턴의 Model에 해당하고 Model에 직접 접근할 수 없고, TypedArray라는 View를 생성해서 그 View를 통해 접근해야 한다.

MVC에서 Model은 여러가지의 View에 의해 사용될 수 있다. 마찬가지로 하나의 ArrayBuffer는 여러가지의 TypedArray에 의해 사용될 수 있다.

쉽게 말해 ArrayBuffer는 배열의 크기를 지정하는데만, 즉 메모리 상에서 연속된 공간을 확보하는데만 사용될 뿐이고, 값을 set/get 하려면 TypedArray를 사용해야 하고, 데이터 타입을 지정하는 것도 TypedArray를 사용해야 한다.

GPU는 전달받은 모든 데이터를 Float로 처리하므로, TypedArray로 지정하는 데이터 타입은 데이터를 보내는 입장에서의 최적화라는 의미만 있다. 

```
var ab = new ArrayBuffer(8);
ab; // ArrayBuffer {}
ab[0]; // undefined
ab[9]; // undedined
console.dir(ab); // byteLength라는 속성밖에 없다.

var ta = new Float32Array(ab);
ta; // [0, 0]
ta[0]; // 0
ta[0] = 3;
ta[0]; // 3
console.dir(ta); // 여러가지 속성 있다.
'''
