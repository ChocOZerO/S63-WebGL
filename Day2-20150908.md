# ProjectBS S63 WebGL - Day 2

## 프로그래밍 일반

### HTML

> **HTML**은 다양한 형태의 미디어를 포함할 수 있는 **컨테이너 시스템**이다.
- HTML은 태그(tag)로 되어 있고, **태그로만 되어 있다**.
- HTML의 태그는 컨테이너다. 이미지를 보여주는 **`img`**, 비디오를 보여주는 **`video`**, 오디오를 들려주는 **`audio`**, 그림을 그릴 수 있게 해주는 **`canvas`** 등 각자 상이한 시스템들이 모두 이 컨테이너에 담겨져서, **컨테이너에 담겨져야만 HTML내에 들어올 수 있다**.

### 상태(State)

> 상태는 **지속되는 변수**를 말한다.
- 상태는 **스코프(Scope)**라는 생존 기간, 생존 공간, 생존 범위 동안 그 **값을 유지**할 수 있고, 그 **값을 변경**할 수도 있다.
- 상태가 유지되면서 흐르는 행위를 **동기화(Synchronization)**라고 한다.
- **상태는 변경되기 전까지는 기존의 상태를 그대로 유지한다.**

사람은 대체로 상태라는 개념에 익숙하다. 가장 널리 사용되는 프로그래밍 언어인 C, Java, JavaScript는 모두 사람에게 익숙한 상태를 다루는 **ALGOL60** 이라는 언어에서 파생되어 발전해온 언어이다.

**사람이 상태에 익숙하기는 하지만 여러 상태를 한꺼번에 관리해야 할 때 특정 시점, 특정 상황에서 여러 상태를 정확히 파악하기는 어려운 일이다**. 상태를 파악하기 어렵기 때문에 **조건문을 통해 상태를 확인**하게 된다. **조건문이나 반복문을 통해 상태를 다루는 프로그래밍 언어를 제어형(또는 절차형) 언어**라고 한다.

조건문의 과도한 사용은 또다시 상태의 파악을 어렵게 하는 요인이 된다. **객체 지향이나 디자인 패턴은 궁극적으로는 과도한 조건문의 사용을 막는 것을 목적**으로 한다.

### 상태 머신(State Machine)

> 말 그대로 **상태를 다루는 기계**이다.
- 상태 머신은 상태를 포함하며, 외부에서 상태에 직접 접근하지 못하게 하고, **상태 머신을 통해서만 접근을 허용**한다.
- 상태 머신은 포함하고 있는 **상태가 변할 때, 상태 머신에 정의되어 있는 다른 일도 할 수 있다**.
- 상태 머신은 객체 지향에서 말하는 캡슐화와 비슷한 면이 있다.

상태 머신의 예는 매우 다양하다.

워드를 떠올려 보자.
워드에서 글자색을 빨간색으로 설정하면 그 이후에 입력하는 모든 글자는, **글자색을 다른 색으로 변경하기 전까지는  빨간색으로 화면에 표시**된다.
이때 빨간색으로 설정하는 행위는 **상태 머신이 제공하는 API를 통해서 글자색이라는 상태를 변경**하며,
빨간색으로 설정되면 글자만 빨간색으로 표시하는 것이 아니라 **상태 머신에 정의된 대로 글자색 아이콘의 색상도 빨간색으로 표시**한다. 

### 컨텍스트(Context)

> 컨텍스트는 어떤 일을 진짜로, 실제로 수행하는 담당자.
- 담당자는 **어떤 일을 수행하기 위해 필요한 정보, 어떤 일이 수행될 수 있는 환경**을 가지고 있다.

컨텍스트(담당자)의 예를 들어 보면,

- style 태그의 담당자는 Sheet 객체.
- canvas 태그의 담당자는 2D Context, WebGL Context 

하나의 HTML은 여러 개의 canvas를 가질 수 있고, canvas마다 각각 자기만의 context를 갖는다.

**GPU는 WebGL 만 처리하는 것이 아니라 OS에 의해 WebGL 외의 여러가지 일을 처리**한다. 이 과정에서 GPU 자원이 부족해지면 **임의로 WebGL 컨텍스트를 소멸**시키기도 한다. 이를 **WebGL 컨텍스트 상실**이라고 하는데, 관련 내용은 책 4장에서 다루고 있다.

## 삼각형 그리기 코드 해부

WebGL에서의 Hello, World는 기본 Primitive인 삼각형 그리기다.

### 큰 순서

![](http://i.imgur.com/TOtoFjz.png)

### 코드 해부

```html
<!DOCTYPE html>
<html lang="ko">
<head>
<title> WebGL 삼각형 그리기 </title>
<meta charset="UTF-8">
<script id="vertexShaderSource" type="x-shader/x-vertex">
// type에는 text/javascript가 아닌 임의의 값을 주면 됨.
// script로 해석되지 않고 무시되도록 하는 것이 목적
attribute vec3 aVertexPosition;
// attribute : 셰이버 변수 종류(attribute | uniform | varying)
// vec3 : 배열 타입, vec3는 3행 배열
// aVertexPosition : 배열 이름, 한 개의 버텍스를 나타낸다. 관습적으로 맨 앞에 a를 붙여서 attribute임을 표시

void main() {
// 버텍스 셰이더 실행부
// 버퍼에 있는 데이터를 gl.drawArrays()의 파라미터에 있는 정보를 기준으로 여러개의 버텍스로 분리하고,
//     버텍스 하나마다 이 main() 함수가 실행되는데,
//     여러 개의 코어에서 이 main() 함수가 각기 다른 버텍스 값을 기준으로 동시에 병렬 실행된다.
    gl_Position = vec4(aVertexPosition, 1.0);
    // vec4() : 네 개의 원소를 파라미터로 받아서 4행 벡터를 반환하는 함수
    // aVertexPosition : 한 개의 버텍스를 나타낸다.
    // 1.0 : 버텍스는 점 이므로 1.0(동차좌표계 내용 참고)
    // gl_Position : 버텍스 셰이더의 내장 변수. 동차좌표계를 사용하므로 vec4 타입만 받는다.
    // 별도의 return 문 없이도 gl_Position에 할당된 값이
    //     파이프라인 상에서 버텍스셰이더의 다음 단계(프리미티브 조립)의 입력값으로 전달된다.
    // 이 예제에서는 단순히 버텍스 하나를 그대로 gl_Position에 할당할 뿐이지만,
    //     일반적인 경우 버텍스에 여러가지 변환 연산을 적용한 후에 gl_Position에 값을 할당한다.
}
</script>
<script id="fragmentShaderSource" type="x-shader/x-fragment">
// type에는 text/javascript가 아닌 임의의 값을 주면 됨.
// script로 해석되지 않고 무시되도록 하는 것이 목적
precision mediump float;
// precision : 데이터의 정밀도 지정
// mediump : 정밀도 수준(highp | mediump | lowp) 대부분의 경우 mediump를 사용
// float : 부동소수형 데이터

void main() {
// 프래그먼트 셰이더는 파이프라인 상에서 래스터라이징의 바로 다음단계에 있으며,
// 래스터라이징의 결과물인 프래그먼트 하나하나마다 이 main() 함수가 실행되는데,
//     여러 개의 코어에서 이 main() 함수가 각기 다른 프래그먼트 값을 기준으로 동시에 병렬 실행된다.
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
    // 1.0, 1.0, 1.0, 1.0 : r, g, b, a 값
    // gl_FragColor : 프래그먼트셰이더의 내장 변수. rgba 값을 사용하므로 vec4 타입만 받는다.
    // 별도의 return 문 없이도 gl_FragColor에 할당된 값이
    //     파이프라인 상에서 프래그먼트 셰이더의 다음 단계(가위 테스트)의 입력값으로 전달된다.
}
</script>
<script type="text/javascript">
function startup() {
    // WebGL 컨텍스트 생성
    var canvas = document.getElementById('webGLCanvas');
    var gl = createGLContext(canvas);

    // 셰이더 준비
    var shaderProgram = setupShaders(gl);

    // 버퍼 준비
    var vertexBuffer = setupBuffers(gl);

    // 화면 준비
    setupViewport(gl, canvas);

    // 그리기
    draw(gl, shaderProgram, vertexBuffer);
}

/**
 * WebGL 컨텍스트 생성
 *     canvas에서 WebGL 컨텍스트를 가져온다.
 *
 * @canvas WebGL 컨텍스트를 가지고 있는 HTML 캔버스 요소
 */
function createGLContext(canvas) {
    var glNames = [ "webgl", "experimental-webgl" ]; // experimental-webgl은 WebGL이 정식으로 지원되지 않을 때 사용되던 이름
    var context;

    for (var i = 0, l = glNames.length; i < l ; i++) {
        // canvas.getContext() 실행 중 에러가 나더라도
        // 스크립트 실행이 정지되지 않고 glNames의 다음 요소로 다시 시도하게 한다.
        try {
            context = canvas.getContext(glNames[i]);
        } catch (e) {}

        if (context)
            return context;
    }

    // 컨텍스트가 없으면 종료
    if (!context) {
        alert("Fail to get WebGL Context");
        return null;
    }
}

/**
 * 셰이더 준비
 *     버텍스 셰이더, 프래그먼트 셰이더의 소스를 읽고, 컴파일하고
 *     셰이더 프로그램에 두 셰이더를 추가하고, 링크한다.
 *
 * @gl WebGL 컨텍스트. gl.~~~()는 버스를 통해 GPU에게 무언가를 시킨다라고 해석하자.
 */
function setupShaders(gl) {
    var vertexShaderSource = document.getElementById('vertexShaderSource').text;

    // 버텍스 셰이더를 담을 그릇을 GPU한테 받아온다.
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);

    // vertexShader라는 그릇에 vertexShaderSource를 담아서 GPU에 보내고
    gl.shaderSource(vertexShader, vertexShaderSource);

    // GPU에게 vertexShader를 컴파일하도록 시킨다.
    gl.compileShader(vertexShader);

    // 컴파일이 제대로 되었는지도 GPU에게 시켜서 확인
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        alert("Error compiling vertex shader : " + gl.getShaderInfoLog(vertexShader));
        // 컴파일이 실패했으면 GPU 메모리에서 vertexShader를 지우도록 GPU에게 시킨다.
        gl.deleteShader(vertexShader);
        return null;
    }

    var fragmentShaderSource = document.getElementById('fragmentShaderSource').text;
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentShaderSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        alert("Error compiling fragment shader : " + gl.getShaderInfoLog(fragmentShader));
        gl.deleteShader(fragmentShader);
        return null;
    }

    // 셰이더 프로그램을 담을 그릇을 GPU한테 얻어온다.
    var shaderProgram = gl.createProgram();

    // 그릇에 컴파일 된 두 셰이더를 담는다.
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);

    // 컴파일 된 두 셰이더를 링크한다. 링크할 때 varying 변수가 연결된다.
    gl.linkProgram(shaderProgram);

    // 링크가 제대로 되었는지도 GPU에게 시켜서 확인
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert("Failed to link shaders");
        // 링크가 실패했으면 GPU 메모리에서 shaderProgram를 지우도록 GPU에게 시킨다.
        gl.deleteProgram(shaderProgram);
        return null;
    }

    // 링크까지 성공했으면 그리는데 shaderProgram을 이용하도록 GPU에게 시킨다.
    gl.useProgram(shaderProgram);

    return shaderProgram;
}

/**
 * 버퍼 준비
 *     삼각형을 그릴 정보를 버퍼에 담는다.
 *
 * @gl WebGL 컨텍스트. gl.~~~()는 버스를 통해 GPU에게 무언가를 시킨다라고 해석하자. *
 */
function setupBuffers(gl) {
    // 버퍼를 담을 그릇을 GPU한테 얻어온다.
    var vertexBuffer = gl.createBuffer();

    // GPU 메모리 내에 있는 gl.ARRAY_BUFFER라는 key에 vertexBuffer를 바인딩하도록 GPU에게 시킨다.
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

    // 삼각형의 버텍스 정보(x, y, z 좌표값)
    // 좌표값은 WebGL이 표시되는 영역의 중심을 원점으로 -1.0 ~ 1.0 사이의 값을 쓴다.
    // 어떤 값을 -1.0 ~ 1.0 사이의 값으로 환산하여 표시하는 것을 정규화라고 한다.
    var triangleVertices = [
         0.0,  0.5,  0.0,
        -0.5, -0.5,  0.0,
         0.5, -0.5,  0.0
    ];

    // 삼각형 정보를 Array Buffer에 담고, Array Buffer의 Float32 형 View인 Typed Array를 반환한다.
    //     Array Buffer, Typed Array는 3강 내용 참고
    var typedArray = new Float32Array(triangleVertices);

    // GPU 메모리 내에 있는 gl.ARRAY_BUFFER라는 key에 바인딩 되어 있는 버퍼(vertexBuffer)에
    //     삼각형 정보를 담도록 GPU에게 시킨다.
    gl.bufferData(gl.ARRAY_BUFFER, typedArray, gl.STATIC_DRAW);

    // 버텍스 하나를 나타내는 정보의 갯수(여기서는 x, y, z 만 사용하므로 3)
    //     나중에 gl.draw~~~()에 사용
    vertexBuffer.itemsPerVertex = 3;

    // // 버텍스의 갯수(여기서는 삼각형이므로 3)
    //     나중에 gl.draw~~~()에 사용
    vertexBuffer.numOfVertices = 3;

    return vertexBuffer;
}

/**
 * 화면 준비
 *     GPU에게 화면의 viewport 범위를 지정하도록 시키고,
 *     viewport 범위를 싹 칠해버릴 색깔을 지정하도록 시킨다.
 *
 * @gl WebGL 컨텍스트. gl.~~~()는 버스를 통해 GPU에게 무언가를 시킨다라고 해석하자.
 * @canvas  viewport 범위 정보를 가지고 있는 캔버스
 */
function setupViewport(gl, canvas) {
    // GPU에게 캔버스의 전체를 viewport 로 지정하도록 시킨다.
    gl.viewport(0, 0, canvas.width, canvas.height);

    // GPU에게 viewport 범위를 싹 칠해버릴 색깔을 지정하도록 시킨다.
    gl.clearColor(0.0, 0.0, 0.2, 1.0);
}

/**
 * 그리기
 *     GPU에 각종 버퍼 정보를 전달해주고, gl.draw~~~()로 GPU에게 그리기를 시킨다.
 * @gl
 * @shaderProgram
 * @vertexBuffer
 */
function draw(gl, shaderProgram, vertexBuffer) {
    // GPU에게 viewport 범위를 지정된 색으로 싹 칠하도록 시킨다.
    gl.clear(gl.COLOR_BUFFER_BIT);

    // shaderProgram 내에서 aVertexPosition에 접근할 수 있는 위치값(포인터)를 GPU한테 시켜서 받아온다.
    var indexOfVertexPositionAttrubite = gl.getAttribLocation(shaderProgram, "aVertexPosition");

    // aVertexPosition의 위치값을 이용해서 aVertexPosition에
    //     현재 gl.ARRAY_BUFFER라는 key에 바인딩 되어 있는 버퍼(vertexBuffer, 삼각형 버텍스정보를 담고 있다)를
    //     할당하도록 GPU에게 시킨다.
    gl.vertexAttribPointer(
        indexOfVertexPositionAttrubite, // index : aVertexPosition에 접근할 수 있는 위치값
        vertexBuffer.itemsPerVertex,    // size : vertexBuffer에 있는 버텍스 하나당 정보의 개수. x, y, z라서 3
        gl.FLOAT,                       // type : vertexBuffer에 담겨있는 데이터 타입(gl.FLOAT | gl.FIXED)
        false,                          // float이 아닌 데이터를 float로 변환할 지 여부
        0,                              // stride :
        0                               // offset :
    );

    // 파라미터로 지정된 위치에 있는 attribute 변수를 활성화 한다.
    //     안쓸 때는 disableVertexAttribArray(index)를 해준다.
    gl.enableVertexAttribArray(
        indexOfVertexPositionAttrubite  // index : enable할 attribute 변수의 위치값
    );

    // GPU에게 최종적으로 그리기를 시킨다.
    gl.drawArrays(
        gl.TRIANGLES, // mode : 그리는 방법을 지정. 정확하게는 버퍼 데이터로 생성할 primitive를 지정
        0,            // first :
        vertexBuffer.numOfVertices  // count : 버텍스의 갯수
    );
}
</script>
</head>
<body onload="startup();">
    <canvas id="webGLCanvas" width="500" height="500"></canvas>
</body>
</html>

```
